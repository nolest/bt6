
# 詳細設計說明書
# 智能寶寶生活記錄應用

**文件版本:** 1.0  
**日期:** 2025年5月31日  
**平台:** iOS  
**架構:** 純客戶端應用，直接與外部API整合

## 目錄

1. [引言](#1-引言)
   1. [目的](#11-目的)
   2. [範圍](#12-範圍)
   3. [參考文件](#13-參考文件)
   4. [術語與縮寫](#14-術語與縮寫)

2. [詳細模組設計](#2-詳細模組設計)
   1. [核心記錄模組](#21-核心記錄模組)
   2. [照片與影片模組](#22-照片與影片模組)
   3. [GAI分析模組](#23-gai分析模組)
   4. [智慧助理模組](#24-智慧助理模組)
   5. [社群互動模組](#25-社群互動模組)
   6. [數據管理模組](#26-數據管理模組)
   7. [設置與用戶管理模組](#27-設置與用戶管理模組)

3. [數據庫詳細設計](#3-數據庫詳細設計)
   1. [CoreData Schema](#31-coredata-schema)
   2. [數據關係](#32-數據關係)
   3. [數據遷移策略](#33-數據遷移策略)

4. [API交互詳細設計](#4-api交互詳細設計)
   1. [iCloud (CloudKit) API](#41-icloud-cloudkit-api)
   2. [Dropbox API](#42-dropbox-api)
   3. [Deepseek GAI API](#43-deepseek-gai-api)
   4. [Facebook API](#44-facebook-api)

5. [安全實現細節](#5-安全實現細節)
   1. [數據加密實現](#51-數據加密實現)
   2. [API密鑰管理實現](#52-api密鑰管理實現)
   3. [訪問控制實現](#53-訪問控制實現)

6. [錯誤處理機制](#6-錯誤處理機制)
   1. [錯誤類型定義](#61-錯誤類型定義)
   2. [錯誤處理流程](#62-錯誤處理流程)
   3. [用戶錯誤提示](#63-用戶錯誤提示)

7. [UI組件接口（佔位）](#7-ui組件接口佔位)

## 1. 引言

### 1.1 目的

本詳細設計說明書（Detailed Design Document, DDD）旨在為「智能寶寶生活記錄」iOS應用的開發提供具體的技術指導。本文檔基於軟體需求說明書（SRS）、系統分析規格書（SAS）和概要設計說明書（HLD），進一步細化了各模組的內部設計、類結構、算法、接口定義、數據庫模式以及與外部API的交互細節，確保開發團隊能夠準確、高效地實現應用功能，並嚴格遵循純客戶端架構。

### 1.2 範圍

本文檔涵蓋了「智能寶寶生活記錄」iOS應用的所有核心模組的詳細設計，包括：

- 各模組的類、結構、協議定義及其職責。
- 關鍵算法的偽代碼或流程圖描述。
- 模組間及與外部API的接口方法簽名與數據格式。
- CoreData數據庫的詳細模式設計。
- API交互的請求/響應格式示例。
- 安全機制的具體實現方案。
- 錯誤處理的詳細策略。

本文檔不包含完整的UI/UX視覺設計稿，但會提及UI組件與後端邏輯的接口。

### 1.3 參考文件

- 軟體需求說明書 (software_requirements_specification.md)
- 系統分析規格書 (system_analysis_specification.md)
- 概要設計說明書 (high_level_design_document.md)
- Apple Human Interface Guidelines
- Swift API Design Guidelines
- Deepseek API 文檔 (假設)
- Facebook Graph API 文檔
- Dropbox API 文檔
- CloudKit 文檔

### 1.4 術語與縮寫

| 術語/縮寫 | 定義 |
|----------|------|
| DDD | 詳細設計說明書 (Detailed Design Document) |
| HLD | 概要設計說明書 (High-Level Design Document) |
| SAS | 系統分析規格書 (System Analysis Specification) |
| SRS | 軟體需求說明書 (Software Requirements Specification) |
| GAI | 通用人工智能 (General Artificial Intelligence) |
| API | 應用程式介面 (Application Programming Interface) |
| UI | 用戶界面 (User Interface) |
| UX | 用戶體驗 (User Experience) |
| CRUD | 創建、讀取、更新、刪除 (Create, Read, Update, Delete) |
| MVVM | 模型-視圖-視圖模型 (Model-View-ViewModel) |
| Combine | Apple的聲明式Swift API，用於處理隨時間變化的值 |
| CoreData | Apple的持久化框架 |
| CloudKit | Apple的iCloud存儲框架 |
| Keychain | iOS安全存儲服務 |
| UUID | 通用唯一標識符 (Universally Unique Identifier) |
| JSON | JavaScript對象表示法 (JavaScript Object Notation) |
| HTTPS | 安全超文本傳輸協議 (Hypertext Transfer Protocol Secure) |
| TLS | 傳輸層安全性協議 (Transport Layer Security) |
| AES | 高級加密標準 (Advanced Encryption Standard) |

## 2. 詳細模組設計

本章節詳細描述HLD中定義的各個模組的內部設計。

### 2.1 核心記錄模組

#### 2.1.1 類/結構/協議定義

```swift
// MARK: - Protocols

protocol ActivityRecordingService {
    func recordActivity(type: ActivityType, startTime: Date, endTime: Date?, details: ActivityDetails, notes: String?) async throws -> ActivityRecord
    func updateActivity(_ record: ActivityRecord) async throws -> ActivityRecord
    func deleteActivity(id: String) async throws
    func getActivity(id: String) async throws -> ActivityRecord?
    func getActivities(for babyId: String, dateRange: DateInterval, type: ActivityType?) async throws -> [ActivityRecord]
}

protocol StatisticsAnalyzingService {
    func generateDailySummary(for babyId: String, date: Date) async throws -> DailySummary
    func generateTrendAnalysis(for babyId: String, activityType: ActivityType, period: AnalysisPeriod) async throws -> TrendAnalysis
    func detectPatterns(for babyId: String, activityType: ActivityType) async throws -> [ActivityPattern]
}

protocol VisualizationDataProviding {
    func prepareChartData(for analysis: TrendAnalysis) -> ChartData
    func prepareSummaryData(for summary: DailySummary) -> SummaryViewData
}

// MARK: - Data Models (Refined from HLD)

struct ActivityRecord: Identifiable, Codable {
    let id: String = UUID().uuidString
    let babyId: String
    let type: ActivityType
    let startTime: Date
    var endTime: Date?
    var duration: TimeInterval? { endTime != nil ? endTime!.timeIntervalSince(startTime) : nil }
    var details: ActivityDetails
    var notes: String?
    let createdByUserId: String
    let createdAt: Date = Date()
    var updatedAt: Date = Date()
}

enum ActivityType: Codable {
    case feeding(FeedingDetails)
    case diaper(DiaperDetails)
    case sleep(SleepDetails)
    // ... other types
    case custom(String, CustomDetails)
}

// Example Detail Structs
struct FeedingDetails: Codable { /* ... properties like amount, source, side ... */ }
struct DiaperDetails: Codable { /* ... properties like type, consistency, color ... */ }
struct SleepDetails: Codable { /* ... properties like quality, location ... */ }
struct CustomDetails: Codable { var fields: [String: String] }

// Analysis Models
struct DailySummary { /* ... total counts, durations, averages ... */ }
struct TrendAnalysis { /* ... data points, trend line parameters ... */ }
struct ActivityPattern { /* ... pattern description, occurrences ... */ }
struct ChartData { /* ... labels, values, colors for chart rendering ... */ }
struct SummaryViewData { /* ... formatted strings for display ... */ }

// MARK: - Core Classes

class DefaultActivityRecordingService: ActivityRecordingService {
    private let dataManager: DataManaging // Injected dependency
    // Implementation of protocol methods using dataManager
}

class DefaultStatisticsAnalyzingService: StatisticsAnalyzingService {
    private let dataManager: DataManaging
    // Implementation of analysis algorithms
}

class DefaultVisualizationDataProvider: VisualizationDataProviding {
    // Implementation of data formatting for UI
}
```

#### 2.1.2 關鍵算法

1.  **活動記錄 (recordActivity)**:
    *   接收輸入數據。
    *   驗證數據有效性 (e.g., startTime <= endTime)。
    *   創建 `ActivityRecord` 對象，生成UUID。
    *   設置 `createdAt`, `updatedAt`, `createdByUserId`。
    *   調用 `dataManager.save(record)`。
    *   異步觸發統計更新通知 (e.g., using Combine Subject or NotificationCenter)。
    *   返回保存的 `ActivityRecord`。

2.  **趨勢分析 (generateTrendAnalysis)**:
    *   從 `dataManager` 獲取指定時間段和類型的活動記錄。
    *   按時間排序記錄。
    *   根據活動類型提取關鍵指標 (e.g., 睡眠時長, 餵奶量)。
    *   應用時間序列分析算法 (e.g., 移動平均, 簡單線性回歸) 計算趨勢。
    *   準備 `TrendAnalysis` 結果對象。

3.  **模式檢測 (detectPatterns)**:
    *   獲取較長時間範圍的活動記錄。
    *   應用模式識別算法 (e.g., 聚類分析, 頻率分析) 尋找重複的作息規律或異常點。
    *   準備 `ActivityPattern` 結果列表。

#### 2.1.3 接口規格

- **ActivityRecordingService**: 如協議定義。
- **StatisticsAnalyzingService**: 如協議定義。
- **VisualizationDataProviding**: 如協議定義。
- **與數據管理模組接口**: 通過注入的 `DataManaging` 協議實現交互。
- **與智慧助理模組接口**: 提供 `ActivityDataProvider` 協議實現，方法如 `getRecentActivities(babyId: String, limit: Int) async throws -> [ActivityRecord]`。

#### 2.1.4 數據結構

- `ActivityRecord`, `ActivityType`, `FeedingDetails`, etc.: 如上定義，使用Codable進行序列化。

#### 2.1.5 錯誤處理

- 定義 `ActivityError` 枚舉 (e.g., `.invalidInput`, `.databaseError`, `.analysisFailed`)。
- 所有 `async throws` 方法在失敗時拋出相應的 `ActivityError`。
- UI層捕獲錯誤並向用戶顯示友好提示。

### 2.2 照片與影片模組

#### 2.2.1 類/結構/協議定義

```swift
// MARK: - Protocols

protocol MediaCaptureService {
    func capturePhoto(completion: @escaping (Result<Data, Error>) -> Void)
    func startVideoRecording(outputURL: URL, completion: @escaping (Error?) -> Void)
    func stopVideoRecording(completion: @escaping (Result<URL, Error>) -> Void)
}

protocol MediaManagingService {
    func saveMedia(data: Data, type: MediaType, babyId: String, tags: [String]?, description: String?) async throws -> MediaItem
    func saveMedia(url: URL, type: MediaType, babyId: String, tags: [String]?, description: String?) async throws -> MediaItem
    func getMediaItem(id: String) async throws -> MediaItem?
    func getMediaItems(for babyId: String, dateRange: DateInterval, type: MediaType?) async throws -> [MediaItem]
    func updateMediaItem(_ item: MediaItem) async throws -> MediaItem
    func deleteMediaItem(id: String) async throws
    func getLocalURL(for item: MediaItem) -> URL?
    func generateThumbnail(for item: MediaItem) async throws -> Data?
}

protocol MediaSyncingService {
    func syncMediaItem(_ item: MediaItem, to provider: CloudSyncProvider) async throws
    func checkSyncStatus(for item: MediaItem) async -> SyncStatus
    // ... other sync related methods
}

// MARK: - Data Models

struct MediaItem: Identifiable, Codable {
    let id: String = UUID().uuidString
    let babyId: String
    let type: MediaType
    let filename: String // e.g., "{UUID}.jpg"
    let relativePath: String // e.g., "Photos/{BabyID}/{YYYY-MM}/"
    var thumbnailFilename: String? // e.g., "{UUID}_thumb.jpg"
    let createdAt: Date = Date()
    var tags: [String]?
    var description: String?
    var analysisResultId: String? // Link to AnalysisResults
    var syncStatus: [CloudSyncProvider: SyncStatus] = [:]
}

enum MediaType: Codable { case photo, video }
enum CloudSyncProvider: Codable { case iCloud, dropbox }
enum SyncStatus: Codable { case notSynced, syncing, synced, error }

// MARK: - Core Classes

// Uses AVFoundation
class DefaultMediaCaptureService: MediaCaptureService { /* ... */ }

class DefaultMediaManagingService: MediaManagingService {
    private let fileManager: FileManager = .default
    private let dataManager: DataManaging
    private let thumbnailGenerator: ThumbnailGenerating // Dependency
    private let mediaDirectory: URL // Base directory for media
    // Implementation using fileManager and dataManager
}

class DefaultMediaSyncingService: MediaSyncingService {
    private let cloudKitService: CloudKitInteracting // Dependency
    private let dropboxService: DropboxInteracting // Dependency
    private let dataManager: DataManaging
    // Implementation coordinating sync with cloud services
}

protocol ThumbnailGenerating {
    func generateThumbnail(from data: Data, type: MediaType, size: CGSize) async throws -> Data?
    func generateThumbnail(from url: URL, type: MediaType, size: CGSize) async throws -> Data?
}
```

#### 2.2.2 關鍵算法

1.  **保存媒體 (saveMedia)**:
    *   接收媒體數據 (Data 或 URL)。
    *   生成 UUID 和文件名。
    *   確定相對路徑 (基於 babyId, type, date)。
    *   創建目標目錄 (如果不存在)。
    *   將媒體數據寫入文件系統中的 `mediaDirectory/relativePath/filename`。
    *   異步調用 `thumbnailGenerator` 生成縮略圖並保存。
    *   創建 `MediaItem` 元數據對象。
    *   調用 `dataManager.save(mediaItem)` 保存元數據。
    *   異步觸發同步任務 (`mediaSyncingService.syncMediaItem`)。
    *   返回 `MediaItem`。

2.  **生成縮略圖 (generateThumbnail)**:
    *   根據 `MediaType` 使用 `UIImage` (for photo) 或 `AVAssetImageGenerator` (for video)。
    *   加載原始媒體數據。
    *   縮放圖像/提取幀到目標尺寸 (`size`)。
    *   將縮略圖數據編碼 (e.g., JPEG or PNG)。
    *   返回縮略圖數據。

3.  **媒體同步 (syncMediaItem)**:
    *   檢查 `MediaItem` 的 `syncStatus`。
    *   根據目標 `provider` (iCloud/Dropbox) 選擇服務。
    *   獲取本地文件 URL。
    *   調用相應雲服務的SDK上傳文件。
    *   更新 `MediaItem` 的 `syncStatus` 並保存。

#### 2.2.3 接口規格

- **MediaCaptureService**: 如協議定義。
- **MediaManagingService**: 如協議定義。
- **MediaSyncingService**: 如協議定義。
- **與GAI分析模組接口**: 提供 `MediaProvider` 協議實現，方法如 `getMediaDataForAnalysis(id: String) async throws -> Data?`。
- **與社群互動模組接口**: 提供 `SharableMediaProvider` 協議實現，方法如 `getShareableURL(for item: MediaItem) -> URL?`。
- **與數據管理模組接口**: 通過注入的 `DataManaging` 協議保存/讀取 `MediaItem` 元數據。

#### 2.2.4 數據結構

- `MediaItem`, `MediaType`, `SyncStatus`: 如上定義。
- 文件系統結構: 如HLD中定義。

#### 2.1.5 錯誤處理

- 定義 `MediaError` 枚舉 (e.g., `.captureFailed`, `.fileWriteError`, `.thumbnailGenerationFailed`, `.syncFailed`, `.itemNotFound`)。
- 方法拋出相應錯誤。

### 2.3 GAI分析模組

#### 2.3.1 類/結構/協議定義

```swift
// MARK: - Protocols

protocol GAIAnalysisPerforming {
    // Check if user enabled cloud analysis
    func isCloudAnalysisEnabled(for babyId: String) -> Bool
    // Request analysis if enabled and quota available
    func requestAnalysis(mediaItemId: String, analysisType: GAAnalysisType) async throws -> AnalysisResult
    // Get cached or previously fetched result
    func getAnalysisResult(id: String) async throws -> AnalysisResult?
    // Get remaining quota info
    func getAnalysisQuotaStatus() async -> GAIQuotaStatus
}

protocol GAIAPIKeyManaging {
    func getAPIKey(for deviceIdHash: String) -> String?
    func reportFailedKey(_ key: String)
}

protocol GAIRateLimiting {
    func allowRequest(type: GAAnalysisType) -> Bool
    func recordRequest(type: GAAnalysisType)
}

// MARK: - Data Models

struct AnalysisResult: Identifiable, Codable {
    let id: String = UUID().uuidString
    let mediaItemId: String
    let analysisDate: Date = Date()
    let analysisType: GAAnalysisType
    var resultData: [String: CodableValue] // Flexible structure for results
    var recommendations: [String]? // Text recommendations
    var developmentScores: [String: Double]? // e.g., {"motor_skills": 0.8}
    var emotionTags: [String]? // e.g., ["happy", "calm"]
}

enum GAAnalysisType: Codable { case emotion, development, milestoneCheck }
struct GAIQuotaStatus { let hourlyRemaining: Int; let dailyRemaining: Int }
struct CodableValue: Codable { /* Helper to store Any Codable value */ }

// MARK: - Core Classes

class DefaultGAIAnalysisPerformer: GAIAnalysisPerforming {
    private let deepseekService: DeepseekAPIInteracting // API client
    private let mediaManager: MediaManagingService
    private let dataManager: DataManaging
    private let settingsManager: SettingsProviding // To check opt-in
    private let apiKeyManager: GAIAPIKeyManaging
    private let rateLimiter: GAIRateLimiting
    private let cache: AnalysisCache // Simple in-memory or disk cache

    // Implementation details:
    // - Check settingsManager.isCloudAnalysisEnabled()
    // - Check rateLimiter.allowRequest()
    // - Get API key from apiKeyManager
    // - Get anonymized media data from mediaManager
    // - Call deepseekService.analyze(...) with key and data
    // - Handle API errors (e.g., quota exceeded, invalid key)
    // - If key fails, call apiKeyManager.reportFailedKey()
    // - Store result via dataManager
    // - Update cache
    // - Call rateLimiter.recordRequest()
}

// Securely stores and retrieves API keys
class SecureGAIAPIKeyManager: GAIAPIKeyManaging {
    private let keychainService: KeychainStoring
    private let obfuscator: StringObfuscating
    private let keyPool: [String] // Obfuscated keys
    // Implementation: Select key based on hash, deobfuscate, handle failures
}

// Tracks request counts locally
class LocalGAIRateLimiter: GAIRateLimiting {
    private var requestTimestamps: [GAAnalysisType: [Date]] = [:]
    private let limits: [GAAnalysisType: (hourly: Int, daily: Int)]
    // Implementation: Check timestamps against limits
}

protocol DeepseekAPIInteracting {
    func analyze(apiKey: String, anonymizedMediaData: Data, type: GAAnalysisType) async throws -> [String: CodableValue]
}

// ... other protocols like SettingsProviding, DataManaging, KeychainStoring ...
```

#### 2.3.2 關鍵算法

1.  **請求分析 (requestAnalysis)**:
    *   獲取 `mediaItemId`。
    *   檢查 `settingsManager.isCloudAnalysisEnabled(for: babyId)`。
    *   檢查 `rateLimiter.allowRequest(type: analysisType)`。
    *   從緩存 `cache.getResult(for: mediaItemId, type: analysisType)` 檢查是否有近期有效結果。
    *   獲取設備ID哈希值。
    *   從 `apiKeyManager.getAPIKey(for: deviceIdHash)` 獲取API密鑰。
    *   從 `mediaManager.getAnonymizedMediaData(id: mediaItemId)` 獲取匿名化數據 (去除EXIF, 模糊背景等)。
    *   調用 `deepseekService.analyze(apiKey: key, anonymizedMediaData: data, type: analysisType)`。
    *   處理API響應：
        *   成功：解析結果，創建 `AnalysisResult`，保存到 `dataManager`，更新緩存，記錄請求 `rateLimiter.recordRequest()`。
        *   失敗 (e.g., 無效密鑰)：調用 `apiKeyManager.reportFailedKey(key)`，拋出錯誤。
        *   失敗 (e.g., 超出配額)：拋出特定錯誤。
    *   返回 `AnalysisResult` 或拋出錯誤。

2.  **API密鑰選擇 (getAPIKey)**:
    *   接收設備ID哈希值。
    *   計算哈希值模 `keyPool.count` 得到索引 `idx`。
    *   從 `keyPool[idx]` 獲取混淆後的密鑰。
    *   使用 `obfuscator.reveal(obfuscatedKey)` 解密/還原密鑰。
    *   返回密鑰。

3.  **速率限制 (allowRequest)**:
    *   獲取 `analysisType` 的請求時間戳列表。
    *   移除超過1小時和24小時的時間戳。
    *   檢查剩餘時間戳數量是否低於小時和每日限制。
    *   返回 `true` 或 `false`。

#### 2.3.3 接口規格

- **GAIAnalysisPerforming**: 如協議定義。
- **與Deepseek API交互**: 通過 `DeepseekAPIInteracting` 協議。
    - `analyze` 方法簽名如上，請求體包含匿名化媒體數據和分析類型，響應體為JSON格式的分析結果。
- **與照片影片模組接口**: 通過注入的 `MediaManagingService` 獲取媒體數據。
- **與數據管理模組接口**: 通過注入的 `DataManaging` 保存/讀取 `AnalysisResult`。
- **與設置模組接口**: 通過注入的 `SettingsProviding` 檢查用戶是否啟用雲端分析。

#### 2.3.4 數據結構

- `AnalysisResult`, `GAAnalysisType`, `GAIQuotaStatus`: 如上定義。
- Deepseek API請求/響應格式 (JSON): 需根據實際API文檔定義，確保只發送匿名化數據。
    - 請求示例: `{ 

    "api_key": "{selected_key}",
    "analysis_type": "{type}",
    "media_data_anonymized": "{base64_encoded_anonymized_data}"
}
`
    - 響應示例: `{ "result_id": "{analysis_uuid}", "status": "processing" }` 或 `{ "emotion_tags": ["happy"], "confidence": 0.9 }`

#### 2.3.5 錯誤處理

- 定義 `GAIError` 枚舉 (e.g., `.apiError`, `.quotaExceeded`, `.invalidAPIKey`, `.analysisOptedOut`, `.rateLimitExceeded`, `.anonymizationFailed`)。
- 方法拋出相應錯誤。
- 特別處理API密鑰失效和配額超限，觸發密鑰報告和用戶通知。

### 2.4 智慧助理模組

#### 2.4.1 類/結構/協議定義

```swift
// MARK: - Protocols

protocol SmartSchedulingService {
    func learnBabyPatterns(babyId: String) async throws
    func generateDailyScheduleSuggestion(babyId: String, date: Date) async throws -> ScheduleSuggestion?
    func getNextPredictedEvent(babyId: String) async throws -> PredictedEvent?
}

protocol ParentingAdviceService {
    func getAdvice(for query: String, babyId: String) async throws -> AdviceResponse
    func getContextualTips(babyId: String, context: AppContext) async throws -> [Tip]
}

protocol EmotionSupportService {
    func detectUserStressLevel() async -> StressLevel // Based on usage patterns, etc.
    func provideSupportMessage(level: StressLevel) -> SupportMessage
    func suggestRelaxationTechnique() -> RelaxationTechnique
}

// MARK: - Data Models

struct ScheduleSuggestion { let suggestedEvents: [SuggestedEvent] }
struct SuggestedEvent { let type: ActivityType; let predictedTime: Date; let confidence: Double }
struct PredictedEvent { let type: ActivityType; let predictedTime: Date }
struct AdviceResponse { let answer: String; let sources: [String]? }
struct Tip { let title: String; let content: String }
enum StressLevel { case low, medium, high }
struct SupportMessage { let text: String }
struct RelaxationTechnique { let name: String; let description: String; let guideURL: URL? }
enum AppContext { case homeScreen, feedingLog, sleepLog }

// MARK: - Core Classes

class DefaultSmartSchedulingService: SmartSchedulingService {
    private let activityProvider: ActivityDataProvider // From Core Recording Module
    private let patternRecognitionModel: PatternRecognition // Local ML model or algorithm
    // Implementation: Fetch data, train/run model, generate suggestions
}

class DefaultParentingAdviceService: ParentingAdviceService {
    private let knowledgeBase: LocalKnowledgeBase // Embedded knowledge
    private let gaiAnalyzer: GAIAnalysisPerforming? // Optional GAI integration for advanced queries
    // Implementation: Process query, search KB, optionally call GAI
}

class DefaultEmotionSupportService: EmotionSupportService {
    private let usageMonitor: AppUsageMonitoring // Tracks interaction patterns
    private let supportContentProvider: SupportContentProviding
    // Implementation: Analyze usage, provide predefined content
}

// ... supporting protocols and classes like PatternRecognition, LocalKnowledgeBase, AppUsageMonitoring ...
```

#### 2.4.2 關鍵算法

1.  **作息模式學習 (learnBabyPatterns)**:
    *   從 `activityProvider` 獲取指定寶寶的歷史活動記錄。
    *   預處理數據 (時間歸一化, 特徵提取)。
    *   應用時間序列分析或簡單的機器學習模型 (e.g., K-Means 聚類, 頻率分析) 識別睡眠、餵食等活動的週期性模式。
    *   將學習到的模式參數存儲 (e.g., 平均間隔, 持續時間分佈)。

2.  **生成排程建議 (generateDailyScheduleSuggestion)**:
    *   加載學習到的模式參數。
    *   基於當前時間和最近的活動記錄，預測下一個可能的活動時間窗口。
    *   生成包含建議活動類型、預測時間和置信度的 `ScheduleSuggestion`。

3.  **育兒建議獲取 (getAdvice)**:
    *   接收用戶查詢 `query`。
    *   對查詢進行自然語言處理 (關鍵詞提取, 意圖識別)。
    *   在 `knowledgeBase` 中搜索匹配的條目。
    *   如果配置了GAI且用戶同意，可將匿名化查詢發送給 `gaiAnalyzer` 以獲取更智能的回答。
    *   整合本地和 (可選的) GAI 結果，生成 `AdviceResponse`。

#### 2.4.3 接口規格

- **SmartSchedulingService**: 如協議定義。
- **ParentingAdviceService**: 如協議定義。
- **EmotionSupportService**: 如協議定義。
- **與核心記錄模組接口**: 通過注入的 `ActivityDataProvider` 獲取數據。
- **與GAI分析模組接口**: 可選地通過注入的 `GAIAnalysisPerforming` 獲取高級分析結果或建議。
- **與數據管理模組接口**: 保存學習到的模式、用戶反饋等。

#### 2.4.4 數據結構

- `ScheduleSuggestion`, `AdviceResponse`, `Tip`, etc.: 如上定義。
- 本地知識庫結構: 可能是一個嵌入式數據庫 (e.g., SQLite) 或 Plist 文件，包含問答對、文章片段等。

#### 2.4.5 錯誤處理

- 定義 `AssistantError` 枚舉 (e.g., `.patternLearningFailed`, `.knowledgeBaseError`, `.gaiQueryFailed`)。
- 方法拋出相應錯誤。

### 2.5 社群互動模組

#### 2.5.1 類/結構/協議定義

```swift
// MARK: - Protocols

protocol FacebookAuthManaging {
    func login(from viewController: UIViewController) async throws -> FacebookSession
    func logout()
    func getCurrentSession() -> FacebookSession?
    func checkPermissions(required: [String]) async throws -> Bool
}

protocol FacebookContentPublishing {
    func publishPost(content: String, media: [PublishableMedia]?, privacy: FacebookPrivacy) async throws -> String // Returns post ID
    func getPublishStatus(postId: String) async throws -> PublishStatus
}

protocol FacebookInteractionFetching {
    func fetchFeed(pageId: String, limit: Int) async throws -> [FacebookPost]
    func fetchComments(postId: String, limit: Int) async throws -> [FacebookComment]
    func postComment(postId: String, message: String) async throws -> String // Returns comment ID
}

// MARK: - Data Models

struct FacebookSession { let userId: String; let accessToken: String; let grantedPermissions: [String] }
struct FacebookPost { let id: String; let author: String; let message: String?; let mediaURL: URL?; let createdAt: Date; let commentCount: Int; let likeCount: Int }
struct FacebookComment { let id: String; let author: String; let message: String; let createdAt: Date }
enum FacebookPrivacy { case everyone, friends, onlyMe }
enum PublishStatus { case pending, success, failed }
enum PublishableMedia { case photo(Data), video(URL) }

// MARK: - Core Classes

// Wrapper around Facebook SDK
class DefaultFacebookAuthManager: FacebookAuthManaging { /* ... */ }

// Wrapper around Facebook Graph API for posting
class DefaultFacebookContentPublisher: FacebookContentPublishing {
    private let graphAPIClient: FacebookGraphAPIClient // Dependency
    // Implementation: Build Graph API requests, handle responses
}

// Wrapper around Facebook Graph API for reading
class DefaultFacebookInteractionFetcher: FacebookInteractionFetching {
    private let graphAPIClient: FacebookGraphAPIClient // Dependency
    // Implementation: Build Graph API requests, handle pagination, parse responses
}

// Helper for making Graph API calls
protocol FacebookGraphAPIClient {
    func performRequest<T: Decodable>(path: String, parameters: [String: Any]?, method: HTTPMethod) async throws -> T
    func uploadMedia<T: Decodable>(path: String, media: PublishableMedia) async throws -> T
}
enum HTTPMethod { case get, post }
```

#### 2.5.2 關鍵算法

1.  **Facebook登錄 (login)**:
    *   調用 Facebook SDK 的 `LoginManager`。
    *   請求必要的權限 (e.g., `public_profile`, `publish_actions`)。
    *   處理登錄回調，獲取 `AccessToken`。
    *   創建並存儲 `FacebookSession` (訪問令牌應安全存儲，e.g., Keychain)。

2.  **發布貼文 (publishPost)**:
    *   檢查當前 `FacebookSession` 和權限。
    *   如果包含媒體，先調用 Graph API 上傳媒體文件，獲取媒體 ID。
    *   構建發布貼文的 Graph API 請求 (`/me/feed` 或 `/{page-id}/feed`)，包含文本內容、媒體 ID (如有) 和隱私設置。
    *   發送 POST 請求。
    *   解析響應，獲取貼文 ID。

3.  **獲取Feed (fetchFeed)**:
    *   檢查當前 `FacebookSession`。
    *   構建獲取 Feed 的 Graph API 請求 (`/{page-id}/feed`)，包含 `limit` 和必要的字段參數。
    *   發送 GET 請求。
    *   解析響應，將 JSON 數據映射到 `FacebookPost` 數組。
    *   處理分頁 (如果需要)。

#### 2.5.3 接口規格

- **FacebookAuthManaging**: 如協議定義。
- **FacebookContentPublishing**: 如協議定義。
- **FacebookInteractionFetching**: 如協議定義。
- **與Facebook SDK/Graph API交互**: 通過封裝類實現。
- **與核心記錄/照片影片模組接口**: 接收可分享的內容 (文本摘要, 媒體URL/Data)。
- **與數據管理模組接口**: 存儲 `FacebookSession` (安全地)，可選地緩存部分社群數據。

#### 2.5.4 數據結構

- `FacebookSession`, `FacebookPost`, `FacebookComment`, etc.: 如上定義。
- Graph API 請求/響應格式 (JSON): 遵循 Facebook Graph API 文檔。

#### 2.5.5 錯誤處理

- 定義 `FacebookError` 枚舉 (e.g., `.loginCancelled`, `.permissionDenied`, `.apiError`, `.tokenExpired`, `.networkError`)。
- 方法拋出相應錯誤。
- 處理訪問令牌過期，需要重新認證。

### 2.6 數據管理模組

#### 2.6.1 類/結構/協議定義

```swift
// MARK: - Core Protocol (Facade)

protocol DataManaging {
    // CRUD Operations for any Storable type
    func save<T: Storable>(_ item: T) async throws
    func save<T: Storable>(_ items: [T]) async throws
    func get<T: Storable>(id: String, type: T.Type) async throws -> T?
    func getAll<T: Storable>(type: T.Type, predicate: NSPredicate?, sortDescriptors: [NSSortDescriptor]?) async throws -> [T]
    func update<T: Storable>(_ item: T) async throws
    func delete<T: Storable>(id: String, type: T.Type) async throws
    func delete<T: Storable>(type: T.Type, predicate: NSPredicate?) async throws

    // Observation
    func observe<T: Storable>(type: T.Type, predicate: NSPredicate?) -> AnyPublisher<[T], Error>

    // Sync Control
    func triggerSync(providers: [CloudSyncProvider]) async throws
    func getSyncStatus() -> [CloudSyncProvider: SyncStatusInfo]

    // Backup/Restore
    func backupData(to provider: CloudSyncProvider) async throws -> BackupResult
    func restoreData(from backupId: String, provider: CloudSyncProvider) async throws -> RestoreResult
}

// MARK: - Supporting Protocols

protocol Storable: Identifiable, Codable { }
protocol CoreDataStoring {
    // Low-level CoreData operations
    func fetch<T: NSManagedObject>(request: NSFetchRequest<T>) async throws -> [T]
    func performBackgroundTask(_ block: @escaping (NSManagedObjectContext) throws -> Void) async throws
    // ... other CoreData helpers
}

protocol FileStoring {
    func saveData(_ data: Data, to path: String) throws
    func loadData(from path: String) throws -> Data?
    func deleteFile(at path: String) throws
    func fileExists(at path: String) -> Bool
    func createDirectory(at path: String) throws
    func getDocumentsDirectory() -> URL
}

protocol KeychainStoring {
    func save(key: String, data: Data) throws
    func load(key: String) throws -> Data?
    func delete(key: String) throws
}

protocol CloudKitInteracting { /* ... CloudKit specific methods ... */ }
protocol DropboxInteracting { /* ... Dropbox specific methods ... */ }

// MARK: - Data Models

struct SyncStatusInfo { let lastSync: Date?; let status: SyncStatus; let error: String? }
struct BackupResult { let backupId: String; let date: Date; let size: Int64 }
struct RestoreResult { let success: Bool; let message: String? }

// MARK: - Core Class (Facade Implementation)

class DefaultDataManager: DataManaging {
    private let coreDataStore: CoreDataStoring
    private let fileStore: FileStoring
    private let keychainStore: KeychainStoring
    private let cloudKitService: CloudKitInteracting
    private let dropboxService: DropboxInteracting
    private let syncCoordinator: SyncCoordinating // Handles sync logic
    private let backupCoordinator: BackupCoordinating // Handles backup/restore logic

    // Implementation delegates calls to appropriate stores/coordinators
    // Handles mapping between Codable models and NSManagedObjects
}

// ... Implementations for CoreDataStore, FileStore, KeychainStore, SyncCoordinator, BackupCoordinator ...
```

#### 2.6.2 關鍵算法

1.  **保存數據 (save<T: Storable>)**:
    *   接收 `Storable` 對象。
    *   判斷數據類型 T。
    *   如果是 CoreData 實體對應的類型：
        *   在後台隊列調用 `coreDataStore.performBackgroundTask`。
        *   在 context 中查找或創建對應的 `NSManagedObject`。
        *   將 `Storable` 對象的屬性映射到 `NSManagedObject`。
        *   保存 context。
    *   如果是文件類型 (e.g., 大型配置)：
        *   序列化對象為 Data。
        *   調用 `fileStore.saveData`。
    *   如果是敏感數據 (e.g., API Key 封裝)：
        *   序列化對象為 Data。
        *   調用 `keychainStore.save`。
    *   異步觸發同步 (`syncCoordinator.scheduleSync(for: item)`)。

2.  **數據同步 (triggerSync)**:
    *   調用 `syncCoordinator.performSync(providers: providers)`。
    *   `SyncCoordinator` 內部：
        *   獲取自上次同步以來變更的本地數據 (使用時間戳或標記)。
        *   對於每個 `provider` (iCloud/Dropbox):
            *   調用相應服務 (e.g., `cloudKitService`) 獲取雲端變更。
            *   比較本地與雲端變更，檢測衝突。
            *   應用衝突解決策略 (e.g., last-write-wins, or store conflict versions)。
            *   上傳本地變更到雲端。
            *   下載雲端變更到本地並應用。
            *   更新本地數據的同步狀態和時間戳。
            *   更新整體同步狀態。

3.  **數據備份 (backupData)**:
    *   調用 `backupCoordinator.createBackup(provider: provider)`。
    *   `BackupCoordinator` 內部：
        *   查詢 CoreData 獲取所有需要備份的數據。
        *   導出數據為中間格式 (e.g., JSON 或自定義二進制格式)。
        *   收集需要備份的媒體文件列表。
        *   將導出的數據和媒體文件打包 (e.g., zip)。
        *   可選地加密備份包。
        *   調用相應雲服務 (e.g., `dropboxService`) 上傳備份包。
        *   記錄備份信息 (ID, date, size)。

#### 2.6.3 接口規格

- **DataManaging**: 作為模塊對外的統一接口，如協議定義。
- **內部接口**: `CoreDataStoring`, `FileStoring`, `KeychainStoring`, `CloudKitInteracting`, `DropboxInteracting`, `SyncCoordinating`, `BackupCoordinating` 等協議定義了內部組件的職責。

#### 2.6.4 數據結構

- `SyncStatusInfo`, `BackupResult`, `RestoreResult`: 如上定義。
- CoreData Schema: 見第3章。
- 文件系統結構: 如HLD中定義。

#### 2.6.5 錯誤處理

- 定義 `DataError` 枚舉 (e.g., `.saveFailed`, `.fetchFailed`, `.deleteFailed`, `.syncConflict`, `.backupFailed`, `.restoreFailed`, `.keychainError`, `.fileAccessError`)。
- `DataManaging` 的方法拋出相應錯誤。
- 內部組件也定義各自的錯誤類型。

### 2.7 設置與用戶管理模組

#### 2.7.1 類/結構/協議定義

```swift
// MARK: - Protocols

protocol SettingsProviding {
    // Get specific setting
    func getSetting<T: Codable>(forKey key: SettingKey) -> T?
    // Observe changes to a setting
    func observeSetting<T: Codable>(forKey key: SettingKey) -> AnyPublisher<T?, Never>
    // Get all settings
    func getAllSettings() -> AppSettings
}

protocol SettingsManaging: SettingsProviding {
    // Update a setting
    func updateSetting<T: Codable>(_ value: T?, forKey key: SettingKey)
    // Reset all settings to default
    func resetToDefaults()
}

protocol FamilyManaging {
    func getCurrentUser() -> UserProfile?
    func updateCurrentUserProfile(_ profile: UserProfile) async throws
    func addFamilyMember(inviteCode: String) async throws -> FamilyMember
    func generateInviteCode() async throws -> String
    func getFamilyMembers() async throws -> [FamilyMember]
    func removeFamilyMember(id: String) async throws
    func updateMemberPermissions(id: String, permissions: MemberPermissions) async throws
}

protocol PrivacyManaging {
    func getPrivacySettings() -> PrivacySettings
    func updatePrivacySetting(key: PrivacySettingKey, value: Bool)
    func isDataSharingEnabled(for service: ExternalService) -> Bool
    func configureAppLock(enabled: Bool, type: AppLockType) throws
    func verifyAppLock() -> Bool
}

// MARK: - Data Models

struct AppSettings: Codable { /* ... theme, notifications, units, etc. ... */ }
struct UserProfile: Codable { let id: String; var name: String; var email: String?; var avatarUrl: String? }
struct FamilyMember: Codable { let id: String; let userId: String; var name: String; var permissions: MemberPermissions }
struct MemberPermissions: Codable { var canRecord: Bool; var canViewStats: Bool; var canManageSettings: Bool }
struct PrivacySettings: Codable { var shareAnalytics: Bool; var cloudAnalysisOptIn: Bool; /* ... */ }
enum SettingKey: String, CaseIterable { /* ... keys for each setting ... */ }
enum PrivacySettingKey: String, CaseIterable { /* ... keys for privacy settings ... */ }
enum ExternalService { case analytics, deepseek, facebook }
enum AppLockType { case passcode, faceID, touchID }

// MARK: - Core Classes

class DefaultSettingsManager: SettingsManaging {
    private let userDefaults: UserDefaults = .standard
    private let defaultSettings: AppSettings
    private var settingPublishers: [SettingKey: CurrentValueSubject<Any?, Never>] = [:]
    // Implementation using UserDefaults and Combine publishers
}

class DefaultFamilyManager: FamilyManaging {
    private let dataManager: DataManaging
    private let currentUserProvider: CurrentUserProviding // Gets current logged-in user ID
    // Implementation using dataManager to store/retrieve UserProfile and FamilyMember
    // Invite code generation/validation might involve a simple cloud function or rely on CloudKit sharing
}

class DefaultPrivacyManager: PrivacyManaging {
    private let settingsManager: SettingsManaging
    private let keychainStore: KeychainStoring
    private let localAuthContext: LAContext = LAContext()
    // Implementation using settingsManager for toggles, keychain for app lock secrets
}
```

#### 2.7.2 關鍵算法

1.  **更新設置 (updateSetting)**:
    *   接收鍵 `key` 和值 `value`。
    *   驗證值的類型是否與 `key` 期望的類型匹配。
    *   將值存儲到 `UserDefaults` (或 Keychain for sensitive settings)。
    *   通過對應的 Combine `CurrentValueSubject` 發布更新。

2.  **觀察設置 (observeSetting)**:
    *   接收鍵 `key`。
    *   查找或創建對應的 `CurrentValueSubject`。
    *   返回其 `AnyPublisher`。

3.  **添加家庭成員 (addFamilyMember)**:
    *   接收邀請碼 `inviteCode`。
    *   驗證邀請碼 (可能需要與 CloudKit 或一個簡單的服務交互)。
    *   如果有效，獲取被邀請用戶的信息。
    *   創建 `FamilyMember` 對象，設置默認權限。
    *   調用 `dataManager.save(familyMember)`。
    *   通知邀請發起者。

4.  **配置應用鎖 (configureAppLock)**:
    *   如果啟用，根據 `type` (密碼/生物識別) 提示用戶設置。
    *   對於密碼，哈希處理後存儲到 Keychain。
    *   對於生物識別，僅記錄啟用狀態 (實際驗證由 `LAContext` 處理)。
    *   如果禁用，從 Keychain 移除密碼哈希。

#### 2.7.3 接口規格

- **SettingsManaging**: 如協議定義。
- **FamilyManaging**: 如協議定義。
- **PrivacyManaging**: 如協議定義。
- **與數據管理模組接口**: 通過注入的 `DataManaging` 存儲用戶配置、家庭成員信息。
- **與其他模組接口**: 其他模組通過注入 `SettingsProviding` 來獲取設置。

#### 2.7.4 數據結構

- `AppSettings`, `UserProfile`, `FamilyMember`, `PrivacySettings`, etc.: 如上定義。
- `UserDefaults` 鍵值對。
- Keychain 條目。

#### 2.7.5 錯誤處理

- 定義 `SettingsError`, `FamilyError`, `PrivacyError` 枚舉 (e.g., `.invalidSettingValue`, `.inviteCodeInvalid`, `.permissionDenied`, `.appLockSetupFailed`, `.keychainError`)。
- 方法拋出相應錯誤。

## 3. 數據庫詳細設計 (CoreData)

### 3.1 CoreData Schema

在 Xcode Data Model Editor 中定義以下實體和屬性：

1.  **CD_Baby**
    *   `id`: String (UUID, Indexed)
    *   `name`: String
    *   `birthDate`: Date
    *   `gender`: String
    *   `profileImageFilename`: String?
    *   `createdAt`: Date
    *   `updatedAt`: Date
    *   `activities`: Relationship to-many CD_ActivityRecord (Inverse: `baby`)
    *   `mediaItems`: Relationship to-many CD_MediaItem (Inverse: `baby`)
    *   `growthRecords`: Relationship to-many CD_GrowthRecord (Inverse: `baby`)
    *   `milestones`: Relationship to-many CD_Milestone (Inverse: `baby`)

2.  **CD_ActivityRecord**
    *   `id`: String (UUID, Indexed)
    *   `typeRawValue`: String (Stores ActivityType enum raw value)
    *   `startTime`: Date (Indexed)
    *   `endTime`: Date?
    *   `detailsData`: Data? (Stores Codable ActivityDetails)
    *   `notes`: String?
    *   `createdByUserId`: String
    *   `createdAt`: Date
    *   `updatedAt`: Date
    *   `syncTimestamp`: Date?
    *   `baby`: Relationship to-one CD_Baby (Inverse: `activities`, Not Optional, Delete Rule: Cascade)

3.  **CD_MediaItem**
    *   `id`: String (UUID, Indexed)
    *   `typeRawValue`: String (Stores MediaType enum raw value)
    *   `filename`: String
    *   `relativePath`: String
    *   `thumbnailFilename`: String?
    *   `createdAt`: Date (Indexed)
    *   `tags`: String? (Comma-separated or JSON array)
    *   `itemDescription`: String?
    *   `syncTimestamp`: Date?
    *   `baby`: Relationship to-one CD_Baby (Inverse: `mediaItems`, Not Optional, Delete Rule: Cascade)
    *   `analysisResult`: Relationship to-one CD_AnalysisResult (Inverse: `mediaItem`, Optional, Delete Rule: Nullify)

4.  **CD_AnalysisResult**
    *   `id`: String (UUID, Indexed)
    *   `analysisDate`: Date
    *   `analysisTypeRawValue`: String
    *   `resultData`: Data? (Stores Codable resultData dictionary)
    *   `recommendationsData`: Data? (Stores Codable recommendations array)
    *   `developmentScoresData`: Data? (Stores Codable scores dictionary)
    *   `emotionTagsData`: Data? (Stores Codable tags array)
    *   `mediaItem`: Relationship to-one CD_MediaItem (Inverse: `analysisResult`, Optional, Delete Rule: Nullify)

5.  **CD_UserProfile**
    *   `id`: String (User ID, Indexed)
    *   `name`: String
    *   `email`: String?
    *   `avatarFilename`: String?
    *   `isCurrentUser`: Bool (Indexed)

6.  **CD_FamilyMember**
    *   `id`: String (UUID, Indexed)
    *   `userId`: String (Indexed)
    *   `name`: String
    *   `permissionsData`: Data? (Stores Codable MemberPermissions)

7.  **CD_GrowthRecord**, **CD_Milestone** (類似結構，包含相關屬性與 `baby` 關係)

### 3.2 數據關係

- **Baby <-> ActivityRecord**: 一對多
- **Baby <-> MediaItem**: 一對多
- **Baby <-> GrowthRecord**: 一對多
- **Baby <-> Milestone**: 一對多
- **MediaItem <-> AnalysisResult**: 一對一 (可選)

### 3.3 數據遷移策略

- 使用 CoreData 的輕量級遷移 (Lightweight Migration) 處理簡單的模式變更 (添加屬性、添加實體、添加關係)。
- 對於複雜的模式變更 (屬性重命名、類型更改、關係更改)，創建新的模型版本和映射模型 (Mapping Model)，執行自定義遷移邏輯。
- 在應用啟動時檢查模型兼容性，並在必要時觸發遷移過程。

## 4. API交互詳細設計

### 4.1 iCloud (CloudKit) API

- **交互方式**: 使用 CloudKit Public/Private Database。
- **記錄類型 (Record Types)**: 對應 CoreData 實體 (e.g., `Baby`, `ActivityRecord`, `MediaItemMetadata`)。
- **數據同步**: 使用 `CKFetchRecordChangesOperation` (基於 Server Change Token) 獲取增量變更，使用 `CKModifyRecordsOperation` 保存本地變更到雲端。
- **衝突解決**: 默認使用 CloudKit 的 `savePolicy = .changedKeys` (last writer wins)，或實現自定義衝突解決邏輯。
- **媒體同步**: `MediaItemMetadata` 記錄類型只包含元數據和一個 `CKAsset` 字段，指向實際存儲在 CloudKit 中的媒體文件。
- **錯誤處理**: 處理 `CKError`，特別是 `.networkUnavailable`, `.notAuthenticated`, `.quotaExceeded`, `.serverRecordChanged` (衝突)。

### 4.2 Dropbox API

- **交互方式**: 使用 Dropbox Official Swift SDK。
- **認證**: OAuth 2.0 流程，安全存儲訪問令牌。
- **主要操作**: `upload(path:input:)`, `download(path:overwrite:destination:)`, `listFolder(path:recursive:includeMediaInfo:includeDeleted:includeHasExplicitSharedMembers:includeMountedFolders:limit:sharedLink:includePropertyGroups:includeNonDownloadableFiles:)`, `delete(path:)`。
- **備份流程**: 將 CoreData 導出和媒體文件打包成 zip 文件，上傳到用戶指定的 Dropbox 文件夾 (e.g., `/Apps/SmartBabyLog/Backups/{timestamp}.zip`)。
- **恢復流程**: 下載指定的備份 zip 文件，解壓，導入數據 (可能需要清空現有數據或合併)。
- **錯誤處理**: 處理 SDK 拋出的錯誤，如網絡錯誤、認證錯誤、文件未找到、空間不足等。

### 4.3 Deepseek GAI API

- **交互方式**: HTTPS POST 請求到指定的 API 端點。
- **認證**: 在請求頭中包含 `Authorization: Bearer {selected_api_key}`。
- **請求體 (JSON)**:
  ```json
  {
    "request_id": "{client_generated_uuid}",
    "analysis_type": "{emotion | development | milestone}", 
    "anonymized_media": {
      "format": "{jpg | png | mp4}",
      "data": "{base64_encoded_anonymized_media_data}"
    },
    "baby_info_anonymized": { // Optional, only non-identifiable info
      "age_months": 12,
      "context": "{e.g., during_playtime}"
    }
  }
  ```
- **響應體 (JSON)**:
  ```json
  // Example for emotion analysis
  {
    "result_id": "{analysis_uuid}",
    "status": "success",
    "results": {
      "dominant_emotion": "happy",
      "emotion_scores": {"happy": 0.9, "neutral": 0.1, ...},
      "timestamp": "{iso8601_date}"
    }
  }
  // Example for error
  {
     "error": {
       "code": "QUOTA_EXCEEDED",
       "message": "Daily analysis quota exceeded."
     }
  }
  ```
- **匿名化處理**: 在客戶端完成，包括移除 EXIF，可能模糊人臉或背景 (如果需要)，不發送任何 PII。
- **密鑰管理與限流**: 嚴格按照 2.3.2 和 5.2 中的設計實現。
- **錯誤處理**: 解析 API 返回的錯誤碼和消息，觸發相應的客戶端邏輯 (重試、報告密鑰、通知用戶)。

### 4.4 Facebook API

- **交互方式**: 使用 Facebook Official Swift SDK 或直接調用 Graph API (HTTPS GET/POST)。
- **認證**: OAuth 2.0 流程，使用 SDK 管理登錄和訪問令牌。
- **主要操作 (Graph API)**:
    - 登錄/權限: SDK 處理。
    - 發布貼文: `POST /{user-id or page-id}/feed` (參數: `message`, `link`, `published`, `scheduled_publish_time`, `attached_media` [上傳媒體後獲得])。
    - 上傳照片: `POST /{user-id or page-id}/photos` (參數: `source`, `caption`, `published`)。
    - 上傳視頻: `POST /{user-id or page-id}/videos` (分塊上傳流程)。
    - 獲取Feed: `GET /{user-id or page-id}/feed` (參數: `fields`, `limit`)。
    - 獲取評論: `GET /{post-id}/comments` (參數: `fields`, `limit`)。
    - 發布評論: `POST /{post-id or comment-id}/comments` (參數: `message`)。
- **權限請求**: 僅請求必要的權限，如 `publish_actions` (如果需要代表用戶發布), `user_posts` (如果需要讀取用戶帖子)。
- **錯誤處理**: 處理 Graph API 錯誤碼，如權限不足、令牌過期、速率限制、內容策略違規等。

## 5. 安全實現細節

### 5.1 數據加密實現

- **庫選擇**: 使用 Apple 的 `CryptoKit` 框架。
- **敏感數據加密**: 對 CoreData 中標記為敏感的屬性 (e.g., `CD_UserProfile.email`) 和 Keychain 中存儲的值進行加密。
    ```swift
    // Example encryption
    func encrypt(text: String, key: SymmetricKey) throws -> Data {
        let data = text.data(using: .utf8)!
        let sealedBox = try AES.GCM.seal(data, using: key)
        return sealedBox.combined! // Nonce + Ciphertext + Tag
    }
    
    // Example decryption
    func decrypt(data: Data, key: SymmetricKey) throws -> String {
        let sealedBox = try AES.GCM.SealedBox(combined: data)
        let decryptedData = try AES.GCM.open(sealedBox, using: key)
        return String(data: decryptedData, encoding: .utf8)!
    }
    ```
- **密鑰管理**: 為每個加密項生成獨立的 `SymmetricKey`，並將密鑰安全地存儲在 Keychain 中，使用只有應用可訪問的訪問控制 (`kSecAttrAccessibleWhenUnlockedThisDeviceOnly`)。
- **備份加密**: 在創建備份 zip 文件時，可使用 `CryptoKit` 或第三方庫 (如 `Zip`) 提供的加密功能，密碼由用戶設置或隨機生成後安全存儲。

### 5.2 API密鑰管理實現

- **密鑰存儲**: 將多個 Deepseek API 密鑰進行混淆 (e.g., Base64 + XOR + 分段) 後硬編碼到應用中。
    ```swift
    // Example (Conceptual) Obfuscation
    let obfuscatedKeys = [
        ("part1_key1", "part2_key1"),
        ("part1_key2", "part2_key2"),
        // ...
    ]
    
    func getKey(index: Int) -> String {
        let parts = obfuscatedKeys[index]
        let keyPart1 = reveal(parts.0) // Deobfuscation logic
        let keyPart2 = reveal(parts.1)
        return keyPart1 + keyPart2
    }
    ```
- **密鑰選擇**: 獲取設備的 `identifierForVendor`，計算其哈希值，然後對密鑰池大小取模，得到要使用的密鑰索引。
- **密鑰保護**: 使用 ProGuard (Android) 或 SwiftShield (iOS) 等工具進一步混淆代碼，增加逆向工程難度。
- **密鑰輪換/禁用**: 雖然客戶端無法完美實現遠程禁用，但可以設計一種機制，在應用啟動時從一個安全端點（如果有的話）獲取一個禁用的密鑰列表，或者依賴應用更新來替換密鑰池。

### 5.3 訪問控制實現

- **應用鎖**: 使用 `LocalAuthentication` 框架。
    ```swift
    let context = LAContext()
    var error: NSError?
    if context.canEvaluatePolicy(.deviceOwnerAuthentication, error: &error) {
        context.evaluatePolicy(.deviceOwnerAuthentication, localizedReason: "Unlock App") { success, authError in
            DispatchQueue.main.async {
                if success {
                    // Authenticated
                } else {
                    // Failed
                }
            }
        }
    } else {
        // Biometry not available/setup, fallback to passcode if configured
    }
    ```
- **密碼鎖**: 如果生物識別不可用或未設置，提示用戶輸入應用內設置的密碼。密碼哈希存儲在 Keychain 中，驗證時將用戶輸入的密碼進行相同哈希處理後比較。
- **家庭成員權限**: 在訪問需要權限的功能時，從 `FamilyManaging` 獲取當前用戶對應的 `MemberPermissions`，並檢查相應的布爾值。

## 6. 錯誤處理機制

### 6.1 錯誤類型定義

- 為每個主要模組或功能域定義清晰的 `Error` 枚舉，遵循 Swift 的錯誤處理模式。
- 包含具體的錯誤 case，例如：
    ```swift
    enum DataError: Error {
        case saveFailed(underlyingError: Error?)
        case fetchFailed(reason: String)
        case itemNotFound(id: String)
        case syncConflict(description: String)
        // ...
    }
    
    enum GAIError: Error {
        case apiError(code: String, message: String)
        case quotaExceeded
        case invalidAPIKey
        case analysisOptedOut
        case rateLimitExceeded
        case networkError(underlyingError: Error)
        // ...
    }
    ```
- 包含底層錯誤信息 (`underlyingError`) 以便調試。

### 6.2 錯誤處理流程

- **拋出**: 在檢測到錯誤條件時，服務或管理類的方法 `throw` 相應的錯誤。
- **捕獲**: 在調用點 (通常是 ViewModel 或 ViewController) 使用 `do-catch` 塊捕獲錯誤。
- **分類**: 在 `catch` 塊中，根據錯誤類型進行分類處理。
- **日誌記錄**: 使用統一的日誌記錄框架 (e.g., OSLog) 記錄詳細的錯誤信息，包括錯誤類型、發生位置、上下文和底層錯誤。
- **重試**: 對於可恢復的錯誤 (e.g., 暫時性網絡錯誤)，實現重試邏輯 (e.g., 指數退避)。
- **用戶通知**: 對於需要用戶了解或干預的錯誤，轉換為用戶友好的消息。
- **狀態更新**: 更新 UI 狀態以反映錯誤情況 (e.g., 顯示錯誤消息，禁用按鈕)。

### 6.3 用戶錯誤提示

- **本地化**: 所有用戶可見的錯誤消息都需要本地化。
- **清晰簡潔**: 避免顯示技術細節，使用用戶能理解的語言。
- **提供建議**: 如果可能，提供解決問題的建議 (e.g., "請檢查網絡連接", "空間不足，請清理存儲")。
- **錯誤代碼**: 可選地顯示一個唯一的錯誤代碼，方便用戶報告問題。
- **UI集成**: 使用 Alert、Toast、Snackbar 或在特定 UI 區域顯示錯誤消息。

## 7. UI組件接口（佔位）

本章節旨在定義業務邏輯層 (ViewModel) 與表現層 (View/ViewController) 之間的接口，具體的 UI 設計稿將在後續階段提供。

### 7.1 ViewModel 接口示例 (MVVM)

```swift
// Example: Activity Log ViewModel
protocol ActivityLogViewModelInput {
    func viewDidLoad()
    func didSelectActivityType(_ type: ActivityType)
    func didEnterStartTime(_ date: Date)
    func didEnterEndTime(_ date: Date)
    func didEnterDetails(_ details: ActivityDetails)
    func didTapSaveButton()
    func didTapDeleteActivity(id: String)
}

protocol ActivityLogViewModelOutput {
    var availableActivityTypes: AnyPublisher<[ActivityTypeViewModel], Never> { get }
    var selectedActivityType: AnyPublisher<ActivityTypeViewModel?, Never> { get }
    var startTime: AnyPublisher<Date, Never> { get }
    var endTime: AnyPublisher<Date?, Never> { get }
    var isSaveButtonEnabled: AnyPublisher<Bool, Never> { get }
    var activityHistory: AnyPublisher<[ActivityHistoryItemViewModel], Never> { get }
    var errorMessages: AnyPublisher<String, Never> { get }
    var isLoading: AnyPublisher<Bool, Never> { get }
}

protocol ActivityLogViewModel: ActivityLogViewModelInput, ActivityLogViewModelOutput { }

// Supporting ViewModels for UI display
struct ActivityTypeViewModel { /* ... display properties ... */ }
struct ActivityHistoryItemViewModel { /* ... display properties ... */ }
```

### 7.2 接口職責

- **Input 協議**: 定義了 View 可以調用 ViewModel 的方法，通常對應用戶交互事件。
- **Output 協議**: 定義了 ViewModel 暴露給 View 的數據流 (使用 Combine `Publisher`)，View 訂閱這些流以更新 UI。
- **ViewModel 實現**: 包含業務邏輯，調用相應的服務 (e.g., `ActivityRecordingService`)，處理數據轉換，管理狀態，並通過 Output `Publisher` 發布更新。

(詳細的 ViewModel 接口將根據每個界面的具體需求在 UI/UX 設計階段後細化)

